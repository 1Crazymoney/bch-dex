# ipfs-swap-service Specification

This document contains a high-level, human-readable specification for the four major architectural areas of the ipfs-swap-service:

- Entities
- Use Cases
- Controllers (inputs)
- Adapters (outputs)

This reflects the [Clean Architecture](https://troutsblog.com/blog/clean-architecture) design pattern.

## Entities

Entities make up the core business concepts. If these entities change, they fundamentally change the entire app.

### Order

An order is created when a new Signal is detected via the P2WDB webhook.
It is destroyed when the UTXO described in the Signal has been detected as spent.

Order entities have the following properties:

- _tokenId_ - The unique ID that identifies the class of token being offered for sale.
- _buyOrSell_ - A string with a value `buy` or `sell` indicating which type of offer this is.
- _rateInSats_ - The rate in terms of tokens-per-currency-unit.
  - For Bitcoin, the min currency is sats.
  - For AVAX, the min currency is nano-Avax.
  - for eCash, the min currency is bits.
- _minSatsToExchange_ - The minimum order size accepted.
- _signature_ - A message signed by the address which created the order.
- _sigMsg_ - The clear-text message used to generate the signature.
- _utxoTxid_ - The TXID of the UTXO used in the order.
- _utxoVout_ - The vout of the UTXO used in the order.
- _numTokens_ - The maximum number of tokens offered for sale.
- _timestamp_ - The ISO time when the order was created.
- _localTimestamp_ - The localized time when the order was created.
- _p2wdbTxid_ - The TXID proof-of-burn used to add the order to the P2WDB.
- _p2wdbHash_ - The hash used to identify the order entry in the P2WDB.
- _lokadId_ - Not used. Provided for future functionality.
- _messageType_ - Not used. Provided for future functionality.
- _messageClass_ - Not used. Provided for future functionality.

### Offer

An Offer Entity is nearly the same as an Order. But while an Order is generated
by a webhook from P2WDB, the Offer Entity is created internally. It is used
to track an Order generated by this application.

The Offer tracks the [HD index address](https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch05.asciidoc#hd-wallets-bip-32bip-44) used to hold tokens or BCH for sale. This is the part of the app concerned with the custody of the funds. It creates a segregated [UTXO](https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc#transaction-outputs-and-inputs) to hold the offered asset. The Offer is automatically destroyed if the UTXO is accidentally spent, which is why it needs to be segregated.

Offer entities have the following properties:

- _offerIpfsId_ - The IPFS ID of the instance of `ipfs-swap-service` that is managing the offer.
- _offerBchAddr_ - The BCH address controlling the offer.
- _offerPubKey_ - The public key used to generate the BCH address, used for encryption.
- _tokenId_ - The unique ID that identifies the class of token being offered for sale.
- _buyOrSell_ - A string with a value `buy` or `sell` indicating which type of offer this is.
- _rateInSats_ - The rate in terms of tokens-per-currency-unit.
  - For Bitcoin, the min currency is sats.
  - For AVAX, the min currency is nano-Avax.
  - for eCash, the min currency is bits.
- _minSatsToExchange_ - The minimum order size accepted.
- _signature_ - A message signed by the address which created the order.
- _sigMsg_ - The clear-text message used to generate the signature.
- _utxoTxid_ - The TXID of the UTXO used in the order.
- _utxoVout_ - The vout of the UTXO used in the order.
- _numTokens_ - The maximum number of tokens offered for sale.
- _timestamp_ - The ISO time when the order was created.
- _localTimestamp_ - The localized time when the order was created.
- _p2wdbTxid_ - The TXID proof-of-burn used to add the order to the P2WDB.
- _p2wdbHash_ - The hash used to identify the order entry in the P2WDB.
- _lokadId_ - Not used. Provided for future functionality.
- _messageType_ - Not used. Provided for future functionality.
- _messageClass_ - Not used. Provided for future functionality.

## Use Cases

Use cases are verbs or actions that is done _to_ an Entity or _between_ Entities.

- **Delete** - This is actually _not_ a use case. It's mentioned here to point out that deleting websites is not necessary. Users can instead move their PSF tokens to a different address, and the merit will go to zero. This will cause the website entry to drop to the bottom of the rankings for its category. Entries with zero merit will be ignored, or possibly garbage-collected.
- **Add to Blacklist** - This is an action that can only be performed by a logged-in user with admin privledges. This allows the admin to prevent entries that violate the ToS from being displayed.
- **Get Merit** - Read the merit value of the Website Entity.
- **Update Merit** - Recalculate and update the merit value of the Website Entity.

## Controllers

Controllers are inputs to the system. When a controller is activated, it causes the system to react in some way.

- **POST Webhook** - This POST REST endpoint will be triggered by a webhook generated by the P2WDB. This will notify the tor-list-api that a new entry has been added to the P2WDB that matches the `appId` of `torlist`. It's a new entry that should be evaluated for inclusion in the tor-list-api local database.
- **GET by Category** - Return the 100 top-ranked Website Entities within a specific category, and with a merit above zero.
- **POST Blacklist** - Creates a new Blacklist Entity. This endpoint is only accessible by an Admin user.
- **24 hour Timer** - A timer which triggers every 24 hours, sets off an update of the database. When it triggers, the following actions should take place:
  - All the website entities should be added to a retry-queue. Highest-merit websites are processed first, lowest merit last.
  - The server will recalculate the merit for each Website Entity in the queue.
    - TODO: Figure out a good garbage collection scheme to remove websites that consistently have no merit.
  - The server will update the 'top 100' in each Category Entity.

## Adapters

Adapters are output libraries so that the business logic doesn't need to know any specific information about the I/O. They are essentially the output of the application.

- **localdb** - An adapter for the local database (MongoDB).
- **ipfs** - An adapter for IPFS and the ipfs-coord library. It allows the app to use the JSON-RPC over IPFS.
