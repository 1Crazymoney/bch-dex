/*
  Use Case library for Offers.
  Offers are created by a webhook trigger from the P2WDB. Offers are a result of
  new data in P2WDB. They differ from Offers, which are generated by a local
  user.
  An Offer is created to match a local Offer, but it's created indirectly, as
  a response to the webhook from the P2WDB. In this way, Offers generated from
  local Offers are no different than Offers generated by other peers.
*/

// Local libraries
const OfferEntity = require('../../entities/offer')
const config = require('../../../config')

class OfferUseCases {
  constructor (localConfig = {}) {
    // console.log('User localConfig: ', localConfig)
    this.adapters = localConfig.adapters
    if (!this.adapters) {
      throw new Error(
        'Instance of adapters must be passed in when instantiating Offer Use Cases library.'
      )
    }

    // Encapsulate dependencies
    this.config = config

    this.offerEntity = new OfferEntity()
    this.OfferModel = this.adapters.localdb.Offer
  }

  // This method is called by the POST /offer REST API controller, which is
  // triggered by a P2WDB webhook.
  async createOffer (offerObj) {
    try {
      console.log('Use Case createOffer(offerObj): ', offerObj)

      // console.log('this.adapters.bchjs: ', this.adapters.bchjs)

      // Verify that UTXO in offer is unspent. If it is spent, then ignore the
      // offer.
      const txid = offerObj.data.utxoTxid
      const vout = offerObj.data.utxoVout
      const utxoStatus = await this.adapters.bchjs.Blockchain.getTxOut(
        txid,
        vout
      )
      console.log('utxoStatus: ', utxoStatus)
      if (utxoStatus === null) return false

      // A new offer gets a status of 'posted'
      offerObj.data.offerStatus = 'posted'

      const offerEntity = this.offerEntity.validate(offerObj)
      console.log('offerEntity: ', offerEntity)

      // Add offer to the local database.
      const offerModel = new this.OfferModel(offerEntity)
      await offerModel.save()

      return true
    } catch (err) {
      console.error('Error in createOffer()')
      throw err
    }
  }

  async listOffers () {
    try {
      return this.OfferModel.find({})
    } catch (error) {
      console.error('Error in use-cases/offer/listOffers()')
      throw error
    }
  }

  // Generate phase 2 of 3 - take the other side of an Offer.
  // Based on this example:
  // https://github.com/Permissionless-Software-Foundation/bch-js-examples/blob/master/bch/applications/collaborate/sell-slp/e2e-exchange/step2-purchase-tx.js
  async takeOffer (offerCid) {
    try {
      console.log('offerCid: ', offerCid)

      // Get the Offer information
      const offerInfo = await this.findOfferByHash(offerCid)
      console.log(`offerInfo: ${JSON.stringify(offerInfo, null, 2)}`)

      // Ensure the offer is in a 'posted' state and not already 'taken'
      if (offerInfo.offerStatus && offerInfo.offerStatus !== 'posted') {
        throw new Error('offer already taken')
      }

      // Verify that UTXO for sale is unspent. Abort if it's been spent.
      const txid = offerInfo.utxoTxid
      const vout = offerInfo.utxoVout
      const utxoStatus = await this.adapters.bchjs.Blockchain.getTxOut(
        txid,
        vout
      )
      console.log('utxoStatus: ', utxoStatus)
      if (utxoStatus === null) {
        console.log(`utxo txid: ${txid}, vout: ${vout}`)
        throw new Error('UTXO does not exist. Aborting.')
      }

      // Ensure the app has enough funds to complete the trade.
      await this.ensureFunds(offerInfo)

      // Get UTXOs.
      const utxos = this.adapters.wallet.bchWallet.utxos.utxoStore
      console.log(`utxos: ${JSON.stringify(utxos, null, 2)}`)

      // TODO: Move funds to create a segrated UTXO for taking the offer

      // Create a partially signed transaction.
      // https://github.com/Permissionless-Software-Foundation/bch-js-examples/blob/master/bch/applications/collaborate/sell-slp/e2e-exchange/step2-purchase-tx.js#L59
      const partialTxHex = await this.adapters.wallet.generatePartialTx(offerInfo)
      // return partialTxHex

      // Create valid Offer object
      const takenOfferInfo = Object.assign({}, offerInfo)
      takenOfferInfo.patialTxHex = partialTxHex
      delete takenOfferInfo.p2wdbHash
      delete takenOfferInfo._id
      takenOfferInfo.offerHash = offerInfo.p2wdbHash

      // Write offer info to the P2WDB
      // TODO: This will trigger the webhook. Find some way of triggering the
      // webhook on new offers, but not on counteroffers
      const p2wdbObj = {
        wif: this.adapters.wallet.bchWallet.walletInfo.privateKey,
        data: takenOfferInfo,
        appId: this.config.p2wdbAppId
      }
      const hash = await this.adapters.p2wdb.write(p2wdbObj)

      // Return the P2WDB CID
      return hash
    } catch (err) {
      console.error('Error in use-cases/offer/takeOffer(): ', err)
      throw err
    }
  }

  // Ensure that the wallet has enough BCH and tokens to complete the requested
  // trade. Will return true if it does. Will throw an error if it doesn't.
  async ensureFunds (offerEntity) {
    try {
      // console.log('this.adapters.wallet: ', this.adapters.wallet.bchWallet)
      // console.log(`walletInfo: ${JSON.stringify(this.adapters.wallet.bchWallet.walletInfo, null, 2)}`)

      await this.adapters.wallet.bchWallet.walletInfoPromise

      // Ensure the app wallet has enough funds to write to the P2WDB.
      const wif = this.adapters.wallet.bchWallet.walletInfo.privateKey
      const canWriteToP2WDB = await this.adapters.p2wdb.checkForSufficientFunds(wif)
      if (!canWriteToP2WDB) throw new Error('App wallet does not have funds for writing to the P2WDB.')

      if (offerEntity.buyOrSell.includes('sell')) {
        // Sell Offer

        // Ensure the app wallet controlls enough BCH to pay for the tokens.
        const satsNeeded = offerEntity.numTokens * parseInt(offerEntity.rateInSats)
        const balance = await this.adapters.wallet.bchWallet.getBalance()
        console.log(`wallet balance: ${balance}, sats needed: ${satsNeeded}`)
        const SATS_MARGIN = 5000
        if (satsNeeded + SATS_MARGIN > balance) { throw new Error('App wallet does not control enough BCH to purchase the tokens.') }

      //
      } else {
        // Buy Offer
        throw new Error('Buy offers are not supported yet.')
      }

      return true
    } catch (err) {
      console.error('Error in ensureFunds()')
      throw err
    }
  }

  async findOfferByHash (p2wdbHash) {
    try {
      if (typeof p2wdbHash !== 'string' || !p2wdbHash) {
        throw new Error('p2wdbHash must be a string')
      }

      const offer = await this.OfferModel.findOne({ p2wdbHash })

      if (!offer) {
        throw new Error('offer not found')
      }

      const offerObject = offer.toObject()
      // return this.offerEntity.validateFromModel(offerObject)

      return offerObject
    } catch (err) {
      console.error('Error in findOffer(): ', err)
      throw err
    }
  }
}

module.exports = OfferUseCases
